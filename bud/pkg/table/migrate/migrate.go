package migrate

import (
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"

	pogo "github.com/livebud/weblog/bud/pkg/table"
)

// GENERATED BY POGO. DO NOT EDIT.

// ErrMigrateNotFound returned if the "public"."migrate" is not found
var ErrMigrateNotFound = errors.New("migrate not found")

// Migrate result data for "public"."migrate"
type Migrate struct {
	Version int64 `json:"version,omitempty"`
}

var _ pogo.Row = (*Migrate)(nil)

// Decode implements pogo.Row
func (m *Migrate) Decode(migrate interface{}) error {
	_migrate, ok := migrate.(*Migrate)
	if !ok {
		return fmt.Errorf(`migrate decode: "%T" is not a "*Migrate"`, migrate)
	}
	*_migrate = *m
	return nil
}

// New "public"."migrate" input
func New() *Input {
	return &Input{}
}

// Input data for "public"."migrate"
type Input struct {
	version *int64
}

var _ pogo.Insertable = (*Input)(nil)

// Version sets the version
func (m *Input) Version(version int64) *Input {
	m.version = &version
	return m
}

// MarshalJSON marshals the "migrate" into JSON
func (m *Input) MarshalJSON() ([]byte, error) {
	return json.Marshal(m)
}

// UnmarshalJSON unmarshals json to a "migrate"
func (m *Input) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, m)
}

// String of the input
// TODO: make this more useful
func (m *Input) String() string {
	return `"public"."migrate"`
}

func (m *Input) columns() map[string]interface{} {
	columns := make(map[string]interface{})

	if m.version != nil {
		columns["version"] = *m.version
	}

	return columns
}

// Insert implements pogo.Insertable
func (m *Input) Insert(db pogo.DB) (pogo.Row, error) {
	return Insert(db, m)
}

// NewFilter creates a new filter
func NewFilter() *Filter {
	return &Filter{}
}

// Filter filters for "public"."migrate"
type Filter struct {
	formats []string
	values  []interface{}
	error   error
}

var _ pogo.Condition = (*Filter)(nil)

// Clause fn
func (f *Filter) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "WHERE",
		Format: strings.Join(f.formats, " AND "),
		Params: f.values,
		Error:  f.error,
	}
}

// And filter
// func (f *Filter) And(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " AND "))
//   return f
// }

// Or filter
// func (f *Filter) Or(filters ...*Filter) *Filter {
//   var clauses []string
//   for _, filter := range filters {
//     _ = filter
//     // clauses = append(clauses, string(filter.Condition()))
//   }
//   f.clauses = append(f.clauses, strings.Join(clauses, " OR "))
//   return f
// }

// Version version equals
func (f *Filter) Version(v int64) *Filter {
	f.formats = append(f.formats, `"version" = %s`)
	f.values = append(f.values, v)
	return f
}

// VersionNot version doesn't equal
func (f *Filter) VersionNot(v int64) *Filter {
	f.formats = append(f.formats, `"version" != %s`)
	f.values = append(f.values, v)
	return f
}

// VersionLt version is less than
func (f *Filter) VersionLt(v int64) *Filter {
	f.formats = append(f.formats, `"version" < %s`)
	f.values = append(f.values, v)
	return f
}

// VersionLte version is less than or equal
func (f *Filter) VersionLte(v int64) *Filter {
	f.formats = append(f.formats, `"version" <= %s`)
	f.values = append(f.values, v)
	return f
}

// VersionGt version is greater than
func (f *Filter) VersionGt(v int64) *Filter {
	f.formats = append(f.formats, `"version" > %s`)
	f.values = append(f.values, v)
	return f
}

// VersionGte version is greater than or equal
func (f *Filter) VersionGte(v int64) *Filter {
	f.formats = append(f.formats, `"version" >= %s`)
	f.values = append(f.values, v)
	return f
}

// VersionIn version is in
func (f *Filter) VersionIn(v ...int64) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"version" IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// VersionNotIn version is not in
func (f *Filter) VersionNotIn(v ...int64) *Filter {
	var rs []string
	if len(v) == 0 {
		f.formats = append(f.formats, `false`)
		return f
	}
	for range v {
		rs = append(rs, "%s")
	}
	f.formats = append(f.formats, fmt.Sprintf(`"version" NOT IN (%s)`, strings.Join(rs, `, `)))
	for _, i := range v {
		f.values = append(f.values, i)
	}
	return f
}

// OrderBy specificies the ORDERBy BY <order>
type OrderBy string

const (
	// ASC sorts by ascending order
	ASC OrderBy = "ASC"

	// DESC sorts by descending order
	DESC OrderBy = "DESC"
)

// NewOrder fn
func NewOrder() *Orderer {
	return &Orderer{}
}

var _ pogo.Condition = (*Orderer)(nil)

// Orderer orders the given fields
type Orderer struct {
	formats []string
}

// Clause fn
func (o *Orderer) Clause() *pogo.Clause {
	return &pogo.Clause{
		Type:   "ORDER BY",
		Format: strings.Join(o.formats, ", "),
	}
}

// Version sorts "version" by an expression
func (o *Orderer) Version(order OrderBy) *Orderer {
	o.formats = append(o.formats, fmt.Sprintf(`"version" %s`, order))
	return o
}

// Model is an empty struct that has all the methods.
// It's primarly used for embedding the methods
// into higher-level models.
type Model struct{}

// Insert a ""public"."migrate"" into the "public"."migrate"
func Insert(db pogo.DB, migrate *Input) (*Migrate, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(migrate.columns(), 0)
	_ = _i

	// sql insert query, primary key provided by sequence
	var sqlstr string
	if len(_c) == 0 {
		sqlstr = `
      INSERT INTO "public"."migrate"
      DEFAULT VALUES
      RETURNING "version"
    `
	} else {
		sqlstr = `
      INSERT INTO "public"."migrate" (` + strings.Join(_c, ", ") + `)
      VALUES (` + strings.Join(_i, ", ") + `)
      RETURNING "version"
    `
	}

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil {
		return nil, e
	}

	return &_migrate, nil
}

// Insert a ""public"."migrate"" into the "public"."migrate"
func (*Model) Insert(db pogo.DB, migrate *Input) (*Migrate, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(migrate.columns(), 0)
	_ = _i

	// sql insert query, primary key provided by sequence
	var sqlstr string
	if len(_c) == 0 {
		sqlstr = `
      INSERT INTO "public"."migrate"
      DEFAULT VALUES
      RETURNING "version"
    `
	} else {
		sqlstr = `
      INSERT INTO "public"."migrate" (` + strings.Join(_c, ", ") + `)
      VALUES (` + strings.Join(_i, ", ") + `)
      RETURNING "version"
    `
	}

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil {
		return nil, e
	}

	return &_migrate, nil
}

// InsertMany ""public"."migrate"" into the "public"."migrate"
func InsertMany(db pogo.DB, migrates ...*Input) ([]*Migrate, error) {
	_migrates := []*Migrate{}
	for _, migrate := range migrates {
		_migrate, err := Insert(db, migrate)
		if err != nil {
			return _migrates, err
		}
		_migrates = append(_migrates, _migrate)
	}
	return _migrates, nil
}

// InsertMany ""public"."migrate"" into the "public"."migrate"
func (*Model) InsertMany(db pogo.DB, migrates ...*Input) ([]*Migrate, error) {
	_migrates := []*Migrate{}
	for _, migrate := range migrates {
		_migrate, err := Insert(db, migrate)
		if err != nil {
			return _migrates, err
		}
		_migrates = append(_migrates, _migrate)
	}
	return _migrates, nil
}

// Find a `Migrate` by some conditions.
func Find(db pogo.DB, conds ...pogo.Condition) (*Migrate, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "version" ` +
		`FROM "public"."migrate" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// Find a `Migrate` by some conditions.
func (*Model) Find(db pogo.DB, conds ...pogo.Condition) (*Migrate, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "version" ` +
		`FROM "public"."migrate" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// FindByVersion a `Migrate` by some conditions.
func FindByVersion(db pogo.DB, version int64) (*Migrate, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "version"
    FROM "public"."migrate"
    WHERE "version" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, version)
	}

	var _migrate Migrate
	row := db.QueryRow(sqlstr, version)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// FindByVersion a `Migrate` by some conditions.
func (*Model) FindByVersion(db pogo.DB, version int64) (*Migrate, error) {
	// sql select query, primary key provided by sequence
	sqlstr := `
    SELECT "version"
    FROM "public"."migrate"
    WHERE "version" = $1
  `

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, version)
	}

	var _migrate Migrate
	row := db.QueryRow(sqlstr, version)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// FindMany finds many "public"."migrate" by a condition
func FindMany(db pogo.DB, conds ...pogo.Condition) ([]*Migrate, error) {
	migrates := []*Migrate{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return migrates, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "version" ` +
		`FROM "public"."migrate" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return migrates, err
	}
	defer rows.Close()

	for rows.Next() {
		var _migrate Migrate
		if e := rows.Scan(&_migrate.Version); e != nil {
			if pogo.IsNoRows(e) {
				return migrates, ErrMigrateNotFound
			}
			return migrates, err
		}
		migrates = append(migrates, &_migrate)
	}
	if rows.Err() != nil {
		return migrates, rows.Err()
	}

	return migrates, nil
}

// FindMany finds many "public"."migrate" by a condition
func (*Model) FindMany(db pogo.DB, conds ...pogo.Condition) ([]*Migrate, error) {
	migrates := []*Migrate{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return migrates, err
	}

	// sql select query, primary key provided by sequence
	sqlstr := `SELECT "version" ` +
		`FROM "public"."migrate" ` +
		_s

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return migrates, err
	}
	defer rows.Close()

	for rows.Next() {
		var _migrate Migrate
		if e := rows.Scan(&_migrate.Version); e != nil {
			if pogo.IsNoRows(e) {
				return migrates, ErrMigrateNotFound
			}
			return migrates, err
		}
		migrates = append(migrates, &_migrate)
	}
	if rows.Err() != nil {
		return migrates, rows.Err()
	}

	return migrates, nil
}

// Update ""public"."migrate"" rows in "public"."migrate" by a condition, returning 1 result
func Update(db pogo.DB, migrate *Input, conds ...pogo.Condition) (*Migrate, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := migrate.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("migrate.Update: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."migrate" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run the query
	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// Update ""public"."migrate"" rows in "public"."migrate" by a condition, returning 1 result
func (*Model) Update(db pogo.DB, migrate *Input, conds ...pogo.Condition) (*Migrate, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := migrate.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("migrate.Update: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."migrate" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run the query
	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// UpdateMany updates ""public"."migrate"" rows in "public"."migrate" by conditions, returning all results
func UpdateMany(db pogo.DB, migrate *Input, conds ...pogo.Condition) ([]*Migrate, error) {
	migrates := []*Migrate{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := migrate.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("migrate.UpdateMany: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."migrate" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return migrates, err
	}
	defer rows.Close()

	for rows.Next() {
		var _migrate Migrate
		if e := rows.Scan(&_migrate.Version); e != nil {
			if pogo.IsNoRows(e) {
				return migrates, ErrMigrateNotFound
			}
			return migrates, err
		}
		migrates = append(migrates, &_migrate)
	}
	if rows.Err() != nil {
		return migrates, rows.Err()
	}

	return migrates, nil
}

// UpdateMany updates ""public"."migrate"" rows in "public"."migrate" by conditions, returning all results
func (*Model) UpdateMany(db pogo.DB, migrate *Input, conds ...pogo.Condition) ([]*Migrate, error) {
	migrates := []*Migrate{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	fields := migrate.columns()

	// prepare the slices
	_c, _i, _v2 := slice(fields, len(_v))
	_v = append(_v, _v2...)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("migrate.UpdateMany: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."migrate" SET ` +
		strings.Join(_u, ", ") + ` ` +
		_s + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return migrates, err
	}
	defer rows.Close()

	for rows.Next() {
		var _migrate Migrate
		if e := rows.Scan(&_migrate.Version); e != nil {
			if pogo.IsNoRows(e) {
				return migrates, ErrMigrateNotFound
			}
			return migrates, err
		}
		migrates = append(migrates, &_migrate)
	}
	if rows.Err() != nil {
		return migrates, rows.Err()
	}

	return migrates, nil
}

// UpdateByVersion a "migrate" in "public"."migrate" by its ""version""
func UpdateByVersion(db pogo.DB, version int64, migrate *Input) (*Migrate, error) {
	// add values to input, overriding existing keys if present in the input
	migrate = migrate.Version(version)

	// get the columns
	fields := migrate.columns()

	// don't update the keys
	delete(fields, "version")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("migrate.UpdateByVersion: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."migrate" SET ` +
		strings.Join(_u, ", ") + ` ` +
		`WHERE "version" = $1 ` +
		`RETURNING "version"`

	// setup the query
	values := []interface{}{}
	values = append(values, version)
	values = append(values, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _migrate Migrate
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// UpdateByVersion a "migrate" in "public"."migrate" by its ""version""
func (*Model) UpdateByVersion(db pogo.DB, version int64, migrate *Input) (*Migrate, error) {
	// add values to input, overriding existing keys if present in the input
	migrate = migrate.Version(version)

	// get the columns
	fields := migrate.columns()

	// don't update the keys
	delete(fields, "version")

	// prepare the slices
	_c, _i, _v := slice(fields, 1)

	// setup the update fields
	var _u []string
	for i, c := range _c {
		_u = append(_u, c+" = "+_i[i])
	}

	// return an error if no update input is provided
	if len(_u) == 0 {
		return nil, errors.New("migrate.UpdateByVersion: no input provided")
	}

	// sql query
	sqlstr := `UPDATE "public"."migrate" SET ` +
		strings.Join(_u, ", ") + ` ` +
		`WHERE "version" = $1 ` +
		`RETURNING "version"`

	// setup the query
	values := []interface{}{}
	values = append(values, version)
	values = append(values, _v...)

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, values...)
	}

	// run the query
	var _migrate Migrate
	row := db.QueryRow(sqlstr, values...)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// Delete `Migrate`s by some conditions. Returns the first result.
// Warning: This can delete more than 1 row
func Delete(db pogo.DB, conds ...pogo.Condition) (*Migrate, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "public"."migrate" ` +
		_s + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// Delete `Migrate`s by some conditions. Returns the first result.
// Warning: This can delete more than 1 row
func (*Model) Delete(db pogo.DB, conds ...pogo.Condition) (*Migrate, error) {
	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return nil, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "public"."migrate" ` +
		_s + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// DeleteMany `Migrate`s by some conditions, returning all results.
func DeleteMany(db pogo.DB, conds ...pogo.Condition) ([]*Migrate, error) {
	migrates := []*Migrate{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return migrates, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "public"."migrate" ` +
		_s + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return migrates, err
	}
	defer rows.Close()

	for rows.Next() {
		var _migrate Migrate
		if e := rows.Scan(&_migrate.Version); e != nil {
			if pogo.IsNoRows(e) {
				return migrates, ErrMigrateNotFound
			}
			return migrates, err
		}
		migrates = append(migrates, &_migrate)
	}
	if rows.Err() != nil {
		return migrates, rows.Err()
	}

	return migrates, nil
}

// DeleteMany `Migrate`s by some conditions, returning all results.
func (*Model) DeleteMany(db pogo.DB, conds ...pogo.Condition) ([]*Migrate, error) {
	migrates := []*Migrate{}

	_s, _v, err := pogo.Conditions(conds...)
	if err != nil {
		return migrates, err
	}

	// sql delete query
	sqlstr := `DELETE FROM "public"."migrate" ` +
		_s + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	rows, err := db.Query(sqlstr, _v...)
	if err != nil {
		return migrates, err
	}
	defer rows.Close()

	for rows.Next() {
		var _migrate Migrate
		if e := rows.Scan(&_migrate.Version); e != nil {
			if pogo.IsNoRows(e) {
				return migrates, ErrMigrateNotFound
			}
			return migrates, err
		}
		migrates = append(migrates, &_migrate)
	}
	if rows.Err() != nil {
		return migrates, rows.Err()
	}

	return migrates, nil
}

// DeleteByVersion deletes a "migrate"
func DeleteByVersion(db pogo.DB, version int64) (*Migrate, error) {
	// sql delete query
	sqlstr := `DELETE FROM "public"."migrate" ` +
		`WHERE "version" = $1 ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, version)
	}

	// run the query
	var _migrate Migrate
	row := db.QueryRow(sqlstr, version)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// DeleteByVersion deletes a "migrate"
func (*Model) DeleteByVersion(db pogo.DB, version int64) (*Migrate, error) {
	// sql delete query
	sqlstr := `DELETE FROM "public"."migrate" ` +
		`WHERE "version" = $1 ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, version)
	}

	// run the query
	var _migrate Migrate
	row := db.QueryRow(sqlstr, version)
	if e := row.Scan(&_migrate.Version); e != nil {
		if pogo.IsNoRows(e) {
			return nil, ErrMigrateNotFound
		}
		return nil, e
	}

	return &_migrate, nil
}

// Upsert inserts a `"public"."migrate"`, updating the row if `"version"` already exists.
func Upsert(db pogo.DB, migrate *Input) (*Migrate, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(migrate.columns(), 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

	// sql query
	sqlstr := `INSERT INTO "public"."migrate" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("version") ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil && !pogo.IsNoRows(e) {
		return nil, e
	}

	return &_migrate, nil
}

// Upsert inserts a `"public"."migrate"`, updating the row if `"version"` already exists.
func (*Model) Upsert(db pogo.DB, migrate *Input) (*Migrate, error) {
	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(migrate.columns(), 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

	// sql query
	sqlstr := `INSERT INTO "public"."migrate" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("version") ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil && !pogo.IsNoRows(e) {
		return nil, e
	}

	return &_migrate, nil
}

// UpsertByVersion inserts a `"public"."migrate"`, updating the row if `"version"` already exists.
func UpsertByVersion(db pogo.DB, version int64, migrate *Input) (*Migrate, error) {
	// add values to input, overriding existing keys if present in the input
	migrate = migrate.Version(version)

	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(migrate.columns(), 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

	// sql query
	sqlstr := `INSERT INTO "public"."migrate" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("version") ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil && !pogo.IsNoRows(e) {
		return nil, e
	}

	return &_migrate, nil
}

// UpsertByVersion inserts a `"public"."migrate"`, updating the row if `"version"` already exists.
func (*Model) UpsertByVersion(db pogo.DB, version int64, migrate *Input) (*Migrate, error) {
	// add values to input, overriding existing keys if present in the input
	migrate = migrate.Version(version)

	// get all the non-nil columns and prepare them for the query
	_c, _i, _v := slice(migrate.columns(), 0)

	// setup the update fields
	var _u []string
	for _, c := range _c {
		_u = append(_u, c+" = excluded."+c)
	}

	// sql query
	sqlstr := `INSERT INTO "public"."migrate" (` + strings.Join(_c, ", ") + `) ` +
		`VALUES (` + strings.Join(_i, ", ") + `) ` +
		`ON CONFLICT ("version") ` +
		`DO UPDATE SET ` + strings.Join(_u, ", ") + ` ` +
		`RETURNING "version"`

	// log query if we've provided a logger
	if pogo.Log != nil {
		pogo.Log(sqlstr, _v...)
	}

	// run query
	var _migrate Migrate
	row := db.QueryRow(sqlstr, _v...)
	if e := row.Scan(&_migrate.Version); e != nil && !pogo.IsNoRows(e) {
		return nil, e
	}

	return &_migrate, nil
}

// slice converts our columns into something the sql driver can understand
func slice(columns map[string]interface{}, offset int) (c []string, i []string, v []interface{}) {
	n := offset + 1
	for col, val := range columns {
		c = append(c, strconv.Quote(col))
		i = append(i, "$"+strconv.Itoa(n))
		v = append(v, val)
		n++
	}
	return c, i, v
}
